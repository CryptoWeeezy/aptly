mod utils;

use ark_bn254::{Bn254, Fq, Fq2, Fr, G1Affine, G2Affine};
use ark_groth16::{prepare_verifying_key, Groth16, PreparedVerifyingKey, Proof, VerifyingKey};

use utils::set_panic_hook;
use wasm_bindgen::prelude::*;
//use ark_serialize::{CanonicalSerialize, CanonicalDeserialize};
use ark_serialize::*;
//use ark_test_curves::BigInt;
use num_bigint::BigUint;
use serde_json::{Number, Value, json};
use serde_wasm_bindgen;
use std::str::FromStr;

// When the `wee_alloc` feature is enabled, use `wee_alloc` as the global
// allocator.
#[cfg(feature = "wee_alloc")]
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

#[wasm_bindgen]
extern "C" {
    fn alert(s: &str);
}

fn fq_from_arr(arr: Vec<Value>) -> Vec<Fq> {
    let mut result: Vec<Fq> = Vec::new();
    for entry in arr {
        result.push(Fq::from(
            BigUint::from_str(entry.as_str().unwrap()).unwrap(),
        ))
    }
    result
}

fn decode_g1(val: &Value) -> G1Affine {
    let arr = val.as_array().unwrap().to_vec();
    let bigs = fq_from_arr(arr);

    let result: G1Affine = G1Affine::new(bigs[0], bigs[1]);
    result
}

fn decode_g2(val: &Value) -> G2Affine {
    let arr = val.as_array().unwrap().to_vec();
    let x_fq = fq_from_arr(arr[0].as_array().unwrap().to_vec());
    let y_fq = fq_from_arr(arr[1].as_array().unwrap().to_vec());

    let x = Fq2::new(x_fq[0], x_fq[1]);
    let y = Fq2::new(y_fq[0], y_fq[1]);

    let result: G2Affine = G2Affine::new(x, y);
    result
}

fn decode_ics(ics: &Vec<Value>) -> Vec<G1Affine> {
    let mut gamma_abc_g1: Vec<G1Affine> = Vec::new();
    for ic in ics {
        let tmp = decode_g1(ic);
        gamma_abc_g1.push(tmp);
    }
    gamma_abc_g1
}

#[wasm_bindgen]
pub fn greet() -> u64 {
    set_panic_hook();
    return 48;
}

#[wasm_bindgen]
pub fn vkey_serialize(vkey: String) -> String {
    //Assumes vkey is a json representation of a vkey generated by snarkjs
    let vkey_json = serde_json::from_str::<Value>(&vkey).unwrap();
    println!("{}", vkey_json);

    let alpha_g1: G1Affine = decode_g1(&vkey_json["vk_alpha_1"]);
    let beta_g2: G2Affine = decode_g2(&vkey_json["vk_beta_2"]);
    let gamma_g2: G2Affine = decode_g2(&vkey_json["vk_gamma_2"]);
    let delta_g2: G2Affine = decode_g2(&vkey_json["vk_delta_2"]);
    let gamma_abc_g1: Vec<G1Affine> = decode_ics(vkey_json["IC"].as_array().unwrap());
    
    let gamma_abc_g1_ = gamma_abc_g1.clone();

    let my_vk: VerifyingKey<Bn254> = VerifyingKey::<Bn254> {
        alpha_g1,
        beta_g2,
        gamma_g2,
        delta_g2,
        gamma_abc_g1,
    };
    let mut compressed_bytes = Vec::new();
    gamma_abc_g1_.serialize_compressed(&mut compressed_bytes).unwrap();
    println!("{}",hex::encode(&compressed_bytes));

    //Alpha g1 compressed 32 bytes
    //Beta g2 64bytes
    //Gamma g2 64
    //Delta 64 bytes
    //168 per gamma_abc_g1
    hex::encode(&compressed_bytes)
}

// Serialize elliptic curve elements to hex-encoded compressed bytes
fn serialize_compressed_to_hex<T: CanonicalSerialize>(element: &T) -> String {
    let mut compressed_bytes = Vec::new();
    element.serialize_compressed(&mut compressed_bytes).unwrap();
    hex::encode(compressed_bytes)
}

// Main serialization function
#[wasm_bindgen]
pub fn vkey_serialize_by_parts(vkey: String) -> String {
    // Assumes vkey is a JSON representation of a vkey generated by snarkjs
    let vkey_json = serde_json::from_str::<Value>(&vkey).unwrap();

    let alpha_g1: G1Affine = decode_g1(&vkey_json["vk_alpha_1"]);
    let beta_g2: G2Affine = decode_g2(&vkey_json["vk_beta_2"]);
    let gamma_g2: G2Affine = decode_g2(&vkey_json["vk_gamma_2"]);
    let delta_g2: G2Affine = decode_g2(&vkey_json["vk_delta_2"]);
    let gamma_abc_g1: Vec<G1Affine> = decode_ics(vkey_json["IC"].as_array().unwrap());

    // Serialize each element to a hex string
    let serialized_alpha_g1 = serialize_compressed_to_hex(&alpha_g1);
    let serialized_beta_g2 = serialize_compressed_to_hex(&beta_g2);
    let serialized_gamma_g2 = serialize_compressed_to_hex(&gamma_g2);
    let serialized_delta_g2 = serialize_compressed_to_hex(&delta_g2);
    let serialized_gamma_abc_g1: Vec<String> = gamma_abc_g1
        .iter()
        .map(|g1| serialize_compressed_to_hex(g1))
        .collect();

    // Build the JSON output
    let result = json!({
        "alpha_g1": serialized_alpha_g1,
        "beta_g2": serialized_beta_g2,
        "gamma_g2": serialized_gamma_g2,
        "delta_g2": serialized_delta_g2,
        "gamma_abc_g1": serialized_gamma_abc_g1
    });

    // Return the JSON string
    result.to_string()
}

#[wasm_bindgen]
pub fn proof_serialize(proof: String) -> String {
    let proof_json = serde_json::from_str::<Value>(&proof).unwrap();
    let pi_a: G1Affine = decode_g1(&proof_json["pi_a"]);
    let pi_b: G2Affine = decode_g2(&proof_json["pi_b"]);
    let pi_c: G1Affine = decode_g1(&proof_json["pi_c"]);
    let my_proof: Proof<Bn254> = Proof::<Bn254> {
        a: pi_a,
        b: pi_b,
        c: pi_c,
    };
    let mut compressed_bytes = Vec::new();
    my_proof
        .serialize_compressed(&mut compressed_bytes)
        .unwrap();
    hex::encode(&compressed_bytes)
}

#[wasm_bindgen]
pub fn public_input_serialize(public_input: String) -> String {
    //let my_public_inputs: [Fr; 2] = [Fr::from(385), Fr::from(5)];
    let mut compressed_input1: Vec<u8> = Vec::new();
    //let mut compressed_input2: Vec<u8> = Vec::new();

   
    let big_int_public = BigUint::from_str(&public_input).unwrap();
    Fr::from(big_int_public)
        .serialize_compressed(&mut compressed_input1)
        .unwrap();

    let compressed_public_inputs: Vec<u8> = [compressed_input1].concat();
    hex::encode(&compressed_public_inputs)
}

#[wasm_bindgen]
pub fn proof_serialize_by_parts(proof: String) -> String {
    // Parse the input proof as JSON
    let proof_json = serde_json::from_str::<Value>(&proof).unwrap();

    // Decode the G1 and G2 elements from the proof JSON
    let pi_a: G1Affine = decode_g1(&proof_json["pi_a"]);
    let pi_b: G2Affine = decode_g2(&proof_json["pi_b"]);
    let pi_c: G1Affine = decode_g1(&proof_json["pi_c"]);

    // Serialize each component to a hex string
    let serialized_a = serialize_compressed_to_hex(&pi_a);
    let serialized_b = serialize_compressed_to_hex(&pi_b);
    let serialized_c = serialize_compressed_to_hex(&pi_c);

    // Build the JSON output with separate hex strings for proof_a, proof_b, and proof_c
    let result = json!({
        "proof_a": serialized_a,
        "proof_b": serialized_b,
        "proof_c": serialized_c
    });

    // Return the JSON string
    result.to_string()
}
